{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#about-this-lesson","title":"About this lesson","text":"<p>This lesson guides through how to complete a Software Management Plan (SMP), introducing the language and concepts required to understand the implications of the different stages and technologies/best-practices involved.</p> <p>In the context of this lesson, a \u201cstage\u201d refers to a set of aspects that commonly go together during the research software development process. These have been defined as a means to elaborate on the key elements of the SMP. In practice, some of the stages will coincide to particular points in the development lifecycle, some could overlap with each other depending on the research development paradigm used, and are not necessarily sequential. </p> <p>The lesson was designed with different target audiences in mind. Visit the learner profiles page if you would like to find if the lesson could be useful to you.</p> <ul> <li>Introduction</li> <li>Chapter 1: Start</li> <li>Chapter 2: Construction</li> <li>Chapter 3: Application</li> <li>Chapter 4: Production</li> <li>Chapter 5: Publication</li> <li>Wrap-up and Conclusions</li> </ul>"},{"location":"course_schedule/","title":"Course schedule","text":""},{"location":"course_schedule/#course-schedule","title":"Course schedule","text":"start end topic 10:00 10:30 coffee! 12:00 13:00 lunch! <p>Generate markdown tables at tablesgenerator.com</p>"},{"location":"instructor-notes/","title":"FIXME","text":"<p>This is a placeholder file. Please add content here. </p>"},{"location":"keywords/","title":"Keyword list / Glossary","text":"<p>Here\u2019s a lit of used keywords:</p>"},{"location":"keywords/#application","title":"Application","text":"<ul> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#changelog","title":"Changelog","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#communication","title":"Communication","text":"<ul> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#community","title":"Community","text":"<ul> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#conclusion","title":"Conclusion","text":"<ul> <li>Conclusions</li> </ul>"},{"location":"keywords/#construction","title":"Construction","text":"<ul> <li>Chapter 2: Construction</li> </ul>"},{"location":"keywords/#core-features","title":"Core features","text":"<ul> <li>Chapter 2: Construction</li> </ul>"},{"location":"keywords/#inception","title":"Inception","text":"<ul> <li>Chapter 1: Start</li> </ul>"},{"location":"keywords/#introduction","title":"Introduction","text":"<ul> <li>Introduction</li> </ul>"},{"location":"keywords/#license","title":"License","text":"<ul> <li>Chapter 1: Start</li> </ul>"},{"location":"keywords/#production","title":"Production","text":"<ul> <li>Chapter 4: Production</li> </ul>"},{"location":"keywords/#prototype","title":"Prototype","text":"<ul> <li>Chapter 2: Construction</li> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#publication","title":"Publication","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#registries","title":"Registries","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#repositories","title":"Repositories","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#scalability","title":"Scalability","text":"<ul> <li>Chapter 4: Production</li> </ul>"},{"location":"keywords/#software-management-plan","title":"Software Management Plan","text":"<ul> <li>Introduction</li> </ul>"},{"location":"keywords/#stability","title":"Stability","text":"<ul> <li>Chapter 4: Production</li> </ul>"},{"location":"keywords/#standards","title":"Standards","text":"<ul> <li>Chapter 1: Start</li> </ul>"},{"location":"keywords/#training","title":"Training","text":"<ul> <li>Introduction</li> </ul>"},{"location":"keywords/#versioning","title":"Versioning","text":"<ul> <li>Chapter 1: Start</li> </ul>"},{"location":"precourse/","title":"Pre-course setup instructions","text":""},{"location":"precourse/#pre-course-setup-instructions","title":"Pre-course setup instructions","text":"<p>Write here anything your learners will need to complete before the course.</p>"},{"location":"profiles/","title":"Learner profiles","text":""},{"location":"profiles/#janet-researcher","title":"Janet - Researcher","text":"<p>Janet is a researcher in an ambitious group. While primarily a wet-lab scientist, Janet shares her time between the lab and the computer where she performs data analysis. After a couple of years, the code used for the analysis was baptized and the group decided to publish it. As Janet only had some basic training in programming she worries that her code may have problems. A colleague suggested her to start by creating a Software Management Plan. After creating the SMP for her code, Janet now understands what she needs to do before publication for her code to be useful and usable to/by others.</p>"},{"location":"profiles/#marc-group-leader-at-company","title":"Marc - Group Leader at Company","text":"<p>Marc is a junior group leader in a pharmaceutical company. For many of the routine computational analysis in the group, software developed over a decade is being used. Most of the software was developed internally with code contributions from different developers over the years. The company is now considering converting the software into a product to be made available to insterested buyers. In order to better understand how to transform the software into a product, Marc was incentivized to elaborate a Software Management Plan. Creating an SMP provided a better understanding of compatibility of different licenses with a commercial model, the importance of testing and product quality control, ensuring the software produces reliable and replicable results for final users.</p>"},{"location":"profiles/#thomas-project-manager","title":"Thomas - Project Manager","text":"<p>Thomas is a project manager at a small non-profit research organization. Three of the projects he\u2019s managing have produced significant amounts of data that now require analysis. He is familiar with different aspects of project management but not software management. His line manager recommended that he would complete a Software Management Plan for a ficticious software in order to get familiar with some of the language and terms used. While completing the SMP, Thomas found many of his questions answered and felt better equipped to manage the software component of his future projects.</p>"},{"location":"profiles/#rose-software-engineer","title":"Rose - Software Engineer","text":"<p>Rose is a trained software engineer with several years of programming experience. She is familiar with most software development best-practices, including versioning, testing and continuous integration (CI), as well as, the importance of documentation and choosing an appropriate license. She is responsible for several unpublished software projects in production for several years. In order to gain awareness of any expert blind spots and as a way to support the next cycle of funding for these projects, she decided to complete Software Management Plans for all of them. She realized she was not aware of how reproducibility became such a mission critical aspect of software use and development and was happy to find that as most of her software was automatically tested, many of the reproducibility aspects were already ensured.</p>"},{"location":"chapters/ch0_introduction/","title":"Introduction","text":"","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#introduction-to-elixir-software-management-plan-smp","title":"Introduction to ELIXIR Software Management Plan (SMP)","text":"","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#overview","title":"Overview","text":"<ol> <li>Target audience (probably similar to the 4OSS lesson)<ol> <li>Research software Engineers (RSEs)(people writing the software need to be aware of the basic principles to follow)</li> <li>Researchers developing software (people writing the software need to be aware of the basic principles to follow)</li> <li>Principal Investigators / Group Leads (they can use the SMP to ensure compliance with best practices)</li> <li>Project managers (they have a vested interest that in-house research output meets criteria and is sustainable)</li> </ol> </li> <li> <p>Levels:</p> <ol> <li>Remember</li> <li>Understand</li> <li>Apply</li> </ol> </li> <li> <p>Prerequisites:</p> <ol> <li>To have a working understanding of the research software development process</li> <li>Coding experience is useful, but not necessary</li> </ol> </li> <li> <p>Goals</p> <ol> <li>Understand which parts of the SMP are critical at various points of the Software Development process.</li> <li>Understand the implications of the different choices provided in the SMP.</li> <li>Be able to fill in the required information across all sections of the SMP in the ELIXIR Software Management Wizard (SMW)</li> </ol> </li> </ol>","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#introduction","title":"Introduction","text":"","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#learning-outcomes","title":"Learning Outcomes","text":"<ol> <li>Explain what is the purpose of a management plan and why this is a good practice for Open Science.</li> <li>List/Highlight what are the key differences between managing data and managing software.</li> <li>Identify the two main groups of stakeholders for the ELIXIR SMP.</li> <li>Describe the five Software Development Stages.</li> <li>Access the SMW and create a project, i.e. a workspace where you can create your SMP </li> </ol>","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#lo-explain-what-is-the-purpose-of-a-management-plan-and-why-this-is-a-good-practice-for-open-science","title":"LO: Explain what is the purpose of a management plan and why this is a good practice for Open Science.","text":"","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#lo-list-the-key-differences-between-managing-data-and-managing-software","title":"LO: List the key differences between managing data and managing software.","text":"","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#management-plans","title":"Management plans","text":"<p>Questions:      - What is a Management Plan?      - Why a Management Plan?      - What are the differences between managing data and managing software?     - What is the difference between a DMP and a SMP?     - (Can we deal with software in the same way as data?) (Use the differences in FAIR principles as an example.) \u2013&gt; to be removed?  </p> <p>Exercise: in groups. Discuss:  1) what could be the purpose of a management plan (in general)?   2) what could be the purpose of a Data Management Plan?  3) what could be the purpose of a Software Management Plan? Solution: each group summarises the answers to the three questions and write them on sticky notes for later use.</p> <p>Data management is the practice of collecting, organising, storing, maintaining, and using data securely, efficiently and cost-effectively. Software developed during the course of research, like data, should be managed appropriately. Although general data management principles can be applied to software development, managing software consists in planning and leading the process of developing and publishing software, since its inception throughout all the phases of its planning, development, delivery, use, and publishing. A management plan is a comprehensive plan that describes the objectives of any given project, clearly defines roles and responsibilities, the strategies used to meet the objectives, and the methods used to measure performance (= the achievement of objectives/deliverables). It is a resource that can be used as a guideline in the initial phases of a project, as well as throughout its execution, thus ensuring that everything operates smoothly. Data Management Plans (DMPs) are a cornerstone of good data management and are now considered a key element of Open Science practices. A DMP describes the data management life cycle for the data to be collected, processed and/or generated within the lifetime of a particular project or activity. A Software Management Plan (SMP) is a device wihch may help formalise a set of structures and goals that ensure the software is accessible and reusable in the short, medium and long term. Although it has a management perspective, the main advantage of an SMP is that it provides clear context to the software that is being developed. In that sense, it addresses several aspects of the software development process such as (a) supporting reproducibility and reusability of the software, (b) allowing funding agencies to have a better grasp of the envisioned development process (as well as the achieved milestones), (c) increasing the awareness of the existing community standards that can/should be used, and (d) ensuring that the software can be easily accessed by the wider community. DMPs and SMPs often come in the form of checklists.  There are a few flavours of SMPs already available in one form or another. The Software Sustainability Institute (SSI) offers a very detailed checklist (Institute, 2018) that is further complemented by an online sustainability evaluation service (SES). Several journals (such as SoftwareX and the Journal of Open Source Software (JOSS)) have checklists that are expected to be filled in by the software authors before any submissions addressing most of the key points of an SMP. Finally, there are funding agencies (such as the Wellcome Trust) that expect a plan for the management of research output, including software, in submitted applications.</p> <p>Reflection: here is an example of an SMP. Explore it and try to answer the following questions: how could you implement it in the development process of your software? I.e., how could it be used? How difficult would be to check whether your software (or software developed in your group) meets all the recommandations provided in this SMP?  </p>","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#lo-identify-the-two-main-groups-of-stakeholders-for-the-elixir-smp","title":"LO: Identify the two main groups of stakeholders for the ELIXIR SMP","text":"","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#smp-stakeholders","title":"SMP stakeholders","text":"<p>Exercise: Who are the stakeholders involved in SMPs? How would this role use the SMP?  The group make a list of potential stakeholders involved in SMPs. Who may be potentially interested in using an SMP? Why?  One first example of stakeholder is a research software developer. Could you identify other profiles? Try to identify at least another one. Use the table template in the shared document (see below):</p> Stakeholders How the stakeholders would use the SMP Research software developers The person writing the software needs to be aware of the basic principles to follow. They would use the SMP as a guide to implement best practices in software development efforts <p>Solution: The group discusses and the instructor facilitates the discussion.</p> <p>We identified two main stakeholders\u2019 groups corresponding to users and adopters. In addition, we defined a group of distinguished personas that are out of the scope of the SMP\u2019s stakeholders, specifically the (a) software users who might also be contributors (e.g. by submitting bugs), and (b) the end-users of the software, who have no involvement with the software development process.</p> <p>Group 1: Users / Benefiter / Enforcers This group includes stakeholders that require access to the SMP for a given software, but are not responsible for filling it in. Funders (e.g ELIXIR, Wellcome Trust) \u2013 Use the SMP in order to assess whether a software fits the funding requirements (e.g adhere to FAIR principles). \u2013 Evaluate if the proposal addresses essential aspects of Research Software Management (incl. \u201cscoring\u201d the software based on their alignment to best practices). \u2013 Ensure that the software is well-done (reproducible, reusable/open, robust) and funding is not wasted.   Policy Makers (e.g. European Commission can use SMPs as a way of \u201cenforcing\u201d their recommendations and policies) \u2013 Use the SMP as a basis, inspiration or requirements for their guidelines or policies in their domain of action. Service providers (e.g. Compute Platform, PaaS, IaaS, SaaS use an SMP in order to ensure compatibility to the minfrastructure offered). \u2013 A service provider would use the SMP to assess if the software meets the qualityand reproducibility standards of the platform. The SMP can therefore also be used as a requirement.  \u2013 To assess the level of maintenance effort necessary to provide access to the software on their platform  Software manager not necessarily contributing to the software - making sure principles are enforced. \u2013 To assess if the software is reliable for ongoing research projects or during the conceptualisation phase of new research projects.  \u2013 To assess if the development process of software is compatible with the timeframe of research projects. Publishers e.g. F1000 should use an SMP in order to ensure software \u201cquality\u201d / availability?). \u2013 To ensure research published can be reproduced by peers with the software that was used to generate the results.  </p> <p>Group 2: Adopters</p> <p>This group includes stakeholders that are primarily responsible for filling a SMP for a given software.  Developer/Researcher the person writing the software needs to be aware of the basic principles to follow.  </p> <p>\u2013 As a guide to implement best practices in ongoing or new software development efforts. \u2013 As a quality filter when considering if existing software meets the needs for new research projects.  </p> <p>PI of a group can use the SMP to ensure compliance with best practices. \u2013 To inform the proposal writing process. \u2013 As a guide to ensure any software developed in the group meets an acceptable quality and technical level in order to maximise the chances of adoption. \u2013 To ensure the team composition supports skills necessary to develop software according with best practices. \u2013 To ensure software can be reused in the future, enabling building on vs reinventing.  \u2013 To increase the bus factor of the project. \u2013 As a checklist prior to publication.  </p> <p>Organisation (Fundee) Vested interest that in-house research output meets criteria and is sustainable - select appropriate SMP. This is the instance where an Institution is attempting to create a policy for internal use (ensure that any \u201cbadged\u201d research software produced under it, aligns to the expectations of the selected SMP).  \u2013 To ensure there is supporting infrastructure at the organisation level. \u2013 To ensure there is a training program / supporting personnel, supporting skillnecessary to implementing the SMP (e.g. software stewards).  </p>","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#lo-describe-the-five-software-development-stages","title":"LO: Describe the five Software Development Stages.","text":"","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#the-elixir-software-management-plan","title":"The ELIXIR Software Management Plan","text":"<p>A key downside of the aforementioned SMPs is that they tend to be rather complex, occasionally requiring deep technical knowledge of the software development process. In order to address these drawbacks, ELIXIR has designed a simplified version of an SMP, tailored for Life Science oriented projects but still general enough so as to be widely used. The primary goal of the ELIXIR SMP is to encourage wider adoption by Life Science researchers, and be as inclusive as possible to the various levels of technical expertise, while also having an explicit connection to the FAIR principles for Research Software (Hong et al., 2021,@lamprecht_towards_2020). A common theme in Life Science researchers is the wide differences in background expertise, with the vast majority of researchers being self-taught research software developers. Having an SMP with a relatively low barrier in technical knowledge, while maintaining all the best practices expected in research software development, may both encourage wider adoption of these practices as well as increase the awareness of the multiple aspects involved in research software development. In terms of structure, the ELIXIR SMP comprises seven areas relevant for software quality, each of which is composed of a collection of targeted questions. The main areas are Accessibility, Documentation, Testing, Interoperability, Versioning, Reproducibility and Recognition, and the questions vary in complexity and requirements. The seven areas, and therefore the questions, can be connected across the five distinct software stages: inception, construction, application, production, publication. </p> <p>Exercise:  The five stages of software development are:   Stage 1: Getting started (requirements, specifications, planning) Stage 2: Construction (prototyping, construction and implementing core functionality)  Stage 3: Application (release and quality assessment) Stage 4: Production (production software working on real-world data in a scalable and stable manner)  Stage 5: Publication (Publishing software and/or research results obtained with the software)  Think about research software you develop (or is developed in your group by others): can you clearly recognise the five phases? When you start a new software project, do you plan its development according to the five stages? When there are more than one contributor to the project, do you assign roles according to the stages? Solution: Write your answers on a shared document. The instructor discuss most interesting answers. </p> <p>Exercise: Alignment of ELIXIR SMP seven areas relevant for software quality to Software Development Stages. The main areas of the ELIXIR SMP are: Accessibility, Documentation, Testing, Interoperability, Versioning, Reproducibility, and Recognition. Using the table provided in the shared document (see below), try to align the areas to the five development stage. This exercise will be done in groups.</p> Stage area(s) reasons Stage1: inception Stage 2: construction Stage 3: application Stage 4: production Stage 5: application &gt; &gt; Solution: Compare and discuss the tables created by different groups. &gt; <p>Exercise: At which stage of the software development the stakeholders would need the SMP most? For each group of identified stakeholders try to answer the questions: at which stage of the software development the stakeholders would need the SMP most? Why? You can use the table template below</p> Stakeholders Stage Why? Funders Policy Makers Service providers Software manager Publishers Developer/Researcher PI of a group Organisation (Fundee) <p>Solution:</p> Stakeholders Stage Funders Depending on the funding scheme; it\u2019s usually at the Inception stage (Stage 1), but it can also be at the Production stage (Stage 4). In all cases, this role would expect the full SMP filled in (either defining what is already in place, or the plan to do this). Policy Makers During early phases of the development of similar policies Service providers When adopting or integrating software into existing platforms or in early stages of the decision process. Software manager While software is at its early stages of development (application or younger). The more mature a software the less likely that it will pose an obstacle to research goals. Publishers At any stage when authors submit software to be published. e.g. checklist used by JOSS. A publisher may also require that software is in the \u201cproduction\u201d or \u201cpublication\u201d stage to be considered for publication. Developer/Researcher At all stages, from inception to publication PI of a group At all stages, from inception to publication Organisation (Fundee) At all stages","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch0_introduction/#lo-access-the-smw-and-create-a-project-ie-a-workspace-where-you-can-create-your-smp_","title":"LO: Access the SMW and create a project, i.e. a workspace where you can create your SMP_","text":"<p>Exercise: Access the SMW and create a project Go to the Software Management Wizard webpage and create a new SMP custom project (not from Project Template).</p> <p>Solution: On the SMP webpage, click on Projects on the left menu. You will end up on a page where you can create your SMP project. Give a name to your project and choose the Software Mangement Plan as Knowledge Model. The list of stages will appear. If and only if you want to fill in the SMP for a given stage(s), select it (them). However, if you want to use all questions, do not select any stage. When you\u2019re done, click on Save. In answering questions, you may want to use the TODO and/or \u201ccomment\u201d functionality. You may add a TODO if you want to remember, e.g., revising one or more of your answers.</p>","tags":["Introduction","Software Management Plan","Training"]},{"location":"chapters/ch1_start/","title":"Chapter 1: Start","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#stage-1-inception","title":"Stage 1: Inception","text":"<p>Authors:</p> <ul> <li>Eva Mart\u00edn del Pico  </li> <li>Jos\u00e9 M\u00aa Fern\u00e1ndez  </li> <li>Renato Alves  </li> </ul> <p>Info</p> <p>This stage starts with the idea of the research project that includes software. In this stage the proposal for the project is written, planning and first steps for the software development are made.</p>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#learning-outcomes","title":"Learning Outcomes","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#1-describe-what-are-the-key-decisions-that-need-to-be-made-during-the-inception-phase","title":"1. Describe what are the key decisions that need to be made during the Inception phase.","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#a-decide-the-software-programming-language-or-framework-for-your-research-project","title":"a. decide the software programming language or framework for your research project.","text":"<p>Narrative: Explain that any programming language is, in principle, fine to write software that helps with the research of your scientific problem, but sometimes there are additional factors to consider. First of all, if you only have experience with a single programming language, the choice of software code language used in the project will naturally be restricted. Any programming language (and its ecosystem) has its own strong points and weaknesses. Most of the time any programming language can be used. You should consider all these aspects alongside your comfort with the language in question. Sometimes you don\u2019t really have a choice. Contraints of the problem, need of use of specialised hardware, and/or existence of libraries, that will cut down the needed development time, being tied to a specific language. In some cases, it is the target ecosystem the determining point. Software communities like bioconductor, machine learning, bioconda or text mining, for instance, only provide feedback on their favoured programming languages.</p> <p>Learning experience</p> <p>Exercise Next challenges explore some implications that choosing one or another programming language can have. </p> <p>Challenge 1</p> <p>I know how to write programs in R and Javascript (through node.js), and I want to write a command line program to process a FASTQ file with custom quality data representation. Which programming language should I use?</p> Solution <p>Any of these programming laungages are more than capable enough to open files, read contents applying transformations and filter the output based on some criteria. Use the one you feel more comfortable with.</p> <p>Challenge 2</p> <p>I want to write a deep-learning software which is able to consume analysed single-cell epigenomic data. Which programming language is best suitable for the task?</p> Solution <p>Most of the single-cell analysis related libraries are available either in R or Python. You can still use any language you already know (for instance, Julia), but it will be harder, as some key libraries will not be available in them.</p>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#b-licence-of-the-software","title":"b. licence of the software","text":"<p>Narrative: Explain what a license is. The license will determine the rules for access and use of the software. It is a legal document, usually composed by a lawyer. A software license is a legal agreement that outlines the terms and conditions under which a piece of software can be used, distributed, and modified. It\u2019s essentially a set of rules that govern how the software can be used and by whom.  When it comes to software licenses, open source licenses are those that allow the source code of the software to be freely distributed and modified. This is in line with the principles of open science, as it allows anyone to access the software and use it for their own purposes. FAIR science, on the other hand, focuses on making sure that scientific data and research can be easily found, accessed, and used by others. A software license that promotes FAIR science would therefore allow others to easily access and use the software, in line with the principles of openness and accessibility. Note for instructor: Open Source Development - An Introduction To Ownership And Licensing Issues</p> <p>Learning experience </p> <p>Exercise The following challenges explore some implications that choosing one license or another can have. They highlight different aspects of software that licese can govern.  </p> <p>Challenge 1</p> <p>In the project we are developing, we want to use a very popular library that has a strong copyleft license, but we would like to distribute our project under a more permissive license. What can we do?</p> Solution <p>We cannot use that library, we have to find an alternative with a compatible license or adopt a strong copyleft license for our project. License governs reusing the software, with implications for the software integrating it.</p> <p>Challenge 2</p> <p>We developed our project, a command line program, and finally realeased it under GPL-3. Someone used that program with no modifications in an application with a privative license. Is that legal?</p> Solution <p>It is perfectly legal, since the applications code that uses my code is not actually being distributed. License can govern the public performance of a software.</p> <p>Challenge 3</p> <p>We are a team of several people happily developing a software in a public GitHub repository. Since we are not ready to share our code yet, we did not add any license. Is this a good way to prevent anyone making copies or use our code?.</p> Solution <p>In absence of a license, the code is under exclusive copyright, which means copying or using it comes with a risk of litigations and take-downs, including the very colaborators of the code! However, in this case, GitHub might be copying your repository and using it as stated in the GitHub Terms and Conditions. Any public GitHub repository can be forked by other users.</p> <p>Narrative Useful resources: - Guides to assist in the election of a license:    - https://choosealicense.com/    - https://www.gnu.org/licenses/license-recommendations.html</p> <ul> <li>Clarifications on frequently asked questions regarding choosing a licenses and compilation of guides by the SSI </li> </ul>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#c-where-the-software-will-be-stored-during-development","title":"c. where the software will be stored during development","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#i-will-determine-how-it-can-be-accessed-by-others","title":"i. will determine how it can be accessed by others","text":"<p>Learning experience </p> <p>Exercise: brainstorm which are the requirements for a system used to store code while it is being developed.  </p> <p>Narrative: Explain the different code hosting options (gitlab, github, bitbucket, sourceforge, \u2026).  Depending on the requirements, like privacy-related ones, some systems will be more suitable (GitLab private instance, for example). </p>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#ii-will-determine-how-it-will-preserved","title":"ii. will determine how it will preserved","text":"<p>Narrative: Self hosted solutions will require us to explicitly push releases of the software source code to either internal backup systems or third party services (osf.io, zenodo, B2SHARE, SSI). Third party public solutions, like GitHub, eases the preservation through the collaboration with Zenodo, automating most of the process. Public preservation solutions usually provide public, permanent identifiers.</p>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#d-what-kind-of-versioning-system-will-be-used","title":"d. what kind of versioning system will be used","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#i-is-used-for-tracking-changes-in-the-software","title":"i. is used for tracking changes in the software","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#ii-serves-as-a-mechanism-for-due-diligence-for-software-projects","title":"ii. serves as a mechanism for due diligence for software projects","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#iii-will-narrow-down-available-online-services-that-can-be-used","title":"iii. will narrow down available online services that can be used","text":"<p>Narrative:  Version control systems are tools that allow developers to keep track of the changes made to a piece of software over time. These systems create a history of all the changes that have been made to the software, and make it easy for developers to roll back to an earlier version if necessary.</p> <p>GitLab and GitHub are two popular hosting services for version control systems. They allow developers to store their code and track changes to it using tools like Git. Both GitLab and GitHub offer a range of features that make it easy for developers to collaborate on projects and manage their code. For example, they both allow users to create branches (i.e. different versions) of their code, review and merge changes made by others, and track issues and bugs. Also, these systems provide continuous integration hooks (i.e. to automatically build binaries) to their facilities or third-party ones.</p> <p>In layman\u2019s terms, you could think of a version control system as a way of keeping track of different versions of a project, like a book. Each time you make a change to the book, the version control system records the change and saves a new version of the book. This makes it easy to go back and see how the book has changed over time, and to revert to an earlier version if necessary. GitLab and GitHub are like the libraries where you can store and manage your books (i.e. code projects). They provide the tools you need to collaborate with other writers, keep track of changes, and make sure your book stays organized.</p> <p>Explain version control systems and available compatible hosting services (GitLab, GitLab). Comparative table: https://chiplicity.readthedocs.io/en/latest/_images/VersionControlSystems.png They very likelly fulfill all the requirements mentioned before. In addtition, some of them are not only hosting services, but offer a wide range of additional tools (issues, docker/package registry, CI/CD, pages, etc). </p> <p>Advantages of version control: - Systematic tracking changes in the software -&gt; version control != version history </p> <p>https://assets-global.website-files.com/5ff3926f03b3ba043ed639d1/601f3c78397f41080913a10e_5ea8b3a73bda8c4a33bb47d0_version-history-comparison-chart.jpeg </p> <ul> <li>Mechanism for due diligence for software projects </li> </ul> <p>However: - The election of the hosting service can limit the options of version control systems -&gt; some repository hosting services like BitBucket only support Git and Mercurial</p>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#e-what-kind-of-input-and-output-standards-the-software-will-have","title":"e. what kind of input and output standards the software will have","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#i-will-greatly-affect-the-level-of-adoption","title":"i. will greatly affect the level of adoption","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#ii-choosing-standards-in-the-field-will-make-it-easier-for-adopters-to-integrate-the-tool-in-their-own-workflows-and-will","title":"ii. Choosing standards in the field will make it easier for adopters to integrate the tool in their own workflows and will","text":"","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#iii-allow-for-reuse-with-their-own-datasets","title":"iii. allow for reuse with their own datasets.","text":"<p>Learning experience</p> <p>Discussion: What are the advantages of using standard data formats?</p> <p>Solution: (among others) </p> <ul> <li>Data reformatting to meet custom data formats comes with high risk of introducing errors.</li> <li>There are libraries to effectively handle common data formats without risk of truncating data.</li> <li>Easier to integrate with other software and use with their own datasets, so increased adoption by users.</li> </ul> <p>Exercise:  Suppose there is no standard format suitable for the tool you are building, how do you reduce the impact of the points raised before? Solution: (among others)</p> <ul> <li>Create a format specification a register it in FAIRsharing -&gt; makes the format public, providing identifier, contact, etc</li> <li>Use a schema to describe the format (machine readable representation) -&gt; facilitates users the task of transforming their data to my custom format</li> <li>Provide a validator for my format -&gt; facilitates users the task of transforming their data to my custom format</li> <li>Provide plenty of data examples for realistic use cases</li> </ul>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#2-for-each-decision-explain-why-its-important","title":"2. For each decision, explain why it\u2019s important.","text":"<p> covered in the previous LO  ```  a. programming language  - i. will determine which existing libraries will be available.  - ii. could narrow the software and scientific ecosystems where it could be (re)used.</p> <p>b. licence of the software   - i. will determine the rules for access and use of the software </p> <p>c. where the software will be stored during development   - i. will determine how it can be accessed by others</p> <p>d. what kind of versioning system will be used   - i. is used for tracking changes in the software  - ii. serves as a mechanism for due diligence for software projects  - ii. will narrow down available online services that can be used to share code</p> <p>e. what kind of input and output standards the software will have</p> <ul> <li>i. will greatly affect the level of adoption</li> <li>ii. Choosing standards in the field will make it easier for adopters to integrate the tool in their own workflows and will </li> <li>iii. allow for reuse with their own datasets.  ``` </li> </ul>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#3-identify-the-specific-smp-questions-that-are-relevant-in-this-phase","title":"3. Identify the specific SMP questions that are relevant in this Phase.","text":"<p>Narrative:  </p> <p>Enumerate the questions: </p> <ul> <li>Accessibilty 1. What is the name of the software? </li> <li>Accessibility 2. How can the software be accessed by third parties? </li> <li>Accessibility 3. Does your software have a license? </li> <li>Interoperability 1. Do you use existing and standard input/output formats? </li> <li>[Not covered in lesson] Interoperability 2. (?) What programming languages are you using in your project? </li> <li>Versioning 1. Do you use a version control system? </li> <li>[Not covered in lesson] Versioning 2. Do you use Semantic Versioning? </li> </ul>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch1_start/#4-using-the-elixir-smw-fill-in-the-appropriate-information-to-each-smp-question-that-is-relevant-to-this-phase","title":"4. Using the ELIXIR SMW, fill in the appropriate information to each SMP question that is relevant to this Phase.","text":"<p>Learning Experience </p> <p>Exercise: </p> <p>Go to the workspace you just created in the SMW and complete the previous questions for a piece of software.</p>","tags":["Inception","License","Versioning","Standards"]},{"location":"chapters/ch2_construction/","title":"Chapter 2: Construction","text":"","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch2_construction/#stage-2-construction-prototyping-construction-and-implementing-core-functionality","title":"Stage 2: Construction (prototyping, construction and implementing core functionality)","text":"<p>Info</p> <p>This is the stage in which the main development of the software is taking place and its core functionality is developed in an iterative process. The software will most likely be developed with the use of toy example input data, developers will document the code while writing it (inline documentation, docstrings etc.). It is also important to ensure that the code functions as intended (e.g. via unit tests or doctests).</p>","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch2_construction/#learning-outcomes","title":"Learning Outcomes:","text":"<p>1. Describe what are the key decisions that need to be made during the Construction phase.</p> <p>What is important? During the Construction phase, there are two main types of important decisions that should be taken: 1. How will you test your software? How will you make sure it works as intended? This also includes decisions about sample input data that will be used to test the software, as well as decisions about what will be the output of your software. 2. How are you going to document your code? The documentation should describe not only what the various parts of code do, but also the actual scope, goals and purpose of the software and how to test it. Therefore, you should decide what would be effective ways to document your software.</p>","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch2_construction/#testing-or-ensuring-software-functions-as-intended","title":"Testing or ensuring software functions as intended","text":"<p>Narrative: </p> <p>There are several types of software testing, which can be broadly categorized into the following categories: - Unit testing: Testing individual units or components of the software project to ensure they function as intended. - Integration testing: Testing the integration of different components or modules of the software project to ensure they work together as expected. - Functional testing: Testing the software\u2019s functionality to ensure it works as specified and meets the requirements. - System testing: Testing the entire software system to ensure it meets the requirements and works as intended.  - Exploratory testing: Ad-hoc testing performed by testers to discover new or unexpected issues in the software. - Regression testing: Testing the software after changes have been made to ensure the changes did not introduce new bugs or issues. - Non-functional testing: Testing the software\u2019s non-functional aspects, such as performance, security, usability, and compatibility. - Stress testing: Testing the software under extreme or unrealistic conditions to determine its performance and stability limits. - Acceptance testing: Testing the software to ensure it meets the customer\u2019s acceptance criteria and is ready for release.</p> <p>Not all kinds of testing are necessary for every project.</p> <p>Learning Experience - Exercise: </p> <p>Challenge 1</p> <p>Learners answer individually the following questions in a shared document:  Think about a piece of software you recently developed or you\u2019re developing. - Did you test it? / Are you testing it? - Which testing approach(es) are you using? - Does your testing approach also include sample example input and output files? - If yes, what are the relevant features of such files? - Which testing approach(es) do you use normally? Would you be able to make a list of the types of tests you usually implement and of the corresponding relevant test parameters?</p> <p>The instructor will discuss the answers and use the discussion as a starting point to deliver the content below.  </p> <p>Learning Experience - Discussion </p> <p>Discussion</p> <p>Do you do test-driven development? Why/why not? </p> <p>Learning Experience - Exercise: </p> <p>Challenge 2</p> <p>Think of a familiar case where test-driven development was not applied (or was not applicable, like in a fast-pace developing environment, early stages of development, prototyping, \u2026). Describe:</p> <ul> <li>Two situations where a test was necessary and why.</li> <li>Two situations where a test was prescindible and why.</li> </ul> <p>Narrative...............................  NOTE: I REALISED THE NARRATIVE REGARDING DIFFERENT (COMMON) TYPES OF TESTING APPROACHES I WANTED TO INSERT HERE IS ALREADY PRESENT IN STAGE 3 (WRITTEN BY EVA). I BELIEVE IT WOULD FIT BETTER HERE (CONSTRUCTION) THAN IN STAGE 3 (APPLICATION). WHAT DO YOU THINK?</p>","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch2_construction/#different-common-types-of-testing-approaches","title":"Different (common) types of testing approaches","text":"<p>\u2013&gt; None, Unit, Integration, Functional, End-to-end, Linting, Regression, Frontend - GUI, Other (e.g.) </p>","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch2_construction/#sample-example-input-and-output-files","title":"Sample example input and output files.","text":"<p>Sample input and output files are necessary for the development of functioning software, and for ensuring that it works as intended. These files should have the same format and content type of the actual data files, i.e. those for which the software is being developed. However, they should not be the actual data files, as these cannot be always kept under control and it may be difficult to decipher how your software behaves when running on actual data file. Aspects you should think about when you create toy example input data are: - file size. The the size of the file should be such that you have complete control over input and output. Ideally, you should be able to do manually the calculations that your software does automatically, so that you know in advance what you can expect the output file will contain. Unless you specifically need to test the performance of the software on big data files, the smaller the input file size, the better. - file format. Input file format need to be exactly the same as the actual data files.  - file content. The content of the file should be exactly of the same type of the actual data file and include all the possibilities and potential exceptions that could be observed in actual data. </p>","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch2_construction/#documenting-your-code","title":"Documenting your code","text":"<p>\u201cThe secret to good documentation is to write it while you\u2019re writing the code. You are your first audience. Explain what you\u2019re doing to yourself. Future you will thank you!\u201d \u2014- Victoria Drake November 24, 2020 \u2013</p>","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch2_construction/#documenting-scope-goals-and-purpose-of-the-software","title":"Documenting scope, goals and purpose of the software","text":"<p>The first thing to document about a software is its purposes. These are: the intended outcome that it is designed to achieve; what problem it solves; why it is being created; etc\u2026 The main purpose of a software can be defined in terms of user needs, technical requirements, problems to solve, etc\u2026 It needs to include both the scope and constraints of the software. </p> <p>Defining the purpose of a software piece is a crucial step in the software development process, as it provides insight, direction and focus to the development team. It also helps to ensure that the software meets the needs and expectations of its intended users. A clear definition of the software\u2019s purpose can also help to guide decision making throughout the development process, and it should be used to evaluate the success of the software after its release.</p> <p>Learning Experience - Exercise: </p> <p>Challenge 2</p> <ol> <li>In groups, each learner will describe to the other group memebers:  - What are the actual scope, goals and purpose of their software (referring to a piece of software they recently developed or are developing);  - How will scope, goals and purpose be documented; - What type of documentation is available or they plan to make available.</li> <li>Each group will then discuss purposes, advantages and disadvantages of the various ways of documenting software/code.</li> <li>The instructor will facilitate a discussion on \u201cHow many different ways can be used to document software? Is there any that is more effective than others?\u201d</li> </ol> <p>*Narrative: Effective ways to document your project</p> <p>From the Berkley Library Guide on how to write good documentation: Best Practices for Writing Documentation:</p> <ol> <li>Include a README file that contains: - A brief description of the project - Installation instructions - A short example/tutorial</li> <li>Allow issue tracker for others</li> <li>Write an API documentation - What a function does - What are the function\u2019s parameters or arguments are - What a function returns</li> <li>Document your code</li> <li>Apply coding conventions, such as file organization, comments, naming conventions, programming practices, etc.</li> <li>Include information for contributors</li> <li>Include citation information</li> <li>Include licensing information</li> <li>Link to your e-mail address at the end</li> <li>List all the versions of the files along with the major edits you did in each version</li> </ol> <p>Learning Experience - Exercise </p> <p>Challenge 1</p> <p>Think of two pieces or components of software you normally use.    Imagine you are working on a new project where you have to provide the compound usage to a third party. But, unfortunatedly, you cannot redistribute the compound usage due to some licensing incompatibilities. Your only alternative is to develop one or both from scratch for your usual purposes. In the worst scenario, two colleagues, both experienced research software engineers, should help you with the reimplementations to speed up the process.</p> <p>To help them get a clear idea of what you want to build, for each software, define: </p> <ol> <li> <p>Purpose, scope and constraints. </p> </li> <li> <p>Two functional tests the finished software components must be able to pass.</p> </li> </ol> <p>2. For each decision, explain why it\u2019s important.</p> <p>Learning Experience - Exercise: </p> <p>Challenge 3</p> <p>The instructor will facilitate a discussion on the following three spects:  - \u201cWhy defining functional tests is important?  Why sample input and output files are necessary?   What\u2019s the purpose of documenting software?\u201d </p> <p>Narrative Why is it important? Sample input and output files are necessary for the development of functioning software, and for ensuring that it works as intended. Having the purpose (scope, and possible constraints) of the software clearly documented is necessary in focussing the development effort and avoiding feature creep. It is also crucial towards defining functional tests. Tests can also act as documentation by showing how the software can be executed and configured, but they should not be a replacement for the in-depth documentation.</p> <p>Defiining how your software will be tested during development is essential to ensure that the code functions as intended. Tests can also act as documentation by showing how the software can be executed and configured</p> <p>Including sample example input and output files is absolutely necessary for the development of functioning software, and for ensuring that it works as intended.</p> <p>Writing good documentation to your software will help create more readable and efficient code with minimal errors. It is necessary in focussing the development effort and avoiding feature creep, and crucial in defining functional tests.</p> <p>From the Berkley Library Guide on how to write good documentation:</p> <p>Documentation effectively connects humans and machines.</p> <p>Why writing documentation is important: For you: - You will be using your code in 6 months - You want people to use your code and give you credit - You want to learn self-determination - Others would be encouraged to contribute to your code For others:  - Others can easily use your code and build upon it For science: - Advances the science - Encourages open science  - Allows reproducibility and transparency</p> <p>3.Identify the specific SMP questions that are relevant in this Phase.</p> <p>SMP questions relevant to this phase:</p> <p>1) Documentation: What type of documentation is available, provided with the software and delivered under the same conditions? Please provide a URL (when available). 2) Documentation: Is the purpose of the software stated in the documentation? 3) Documentation: Does the documentation describe how to test the software? 4) Testing: What type of testing do you use? 5) Testing: Are sample data and/or parameters that can be used to test the software available with the source code?</p> <p>4.Using the ELIXIR SMW, fill in the appropriate information to each SMP question that is relevant to this Phase.</p> <p>Learning Experience - Exercise: </p> <p>Challenge 3</p> <p>Go to the project in the SMW and complete the previous questions for a piece of software.</p>","tags":["Construction","Prototype","Core features"]},{"location":"chapters/ch3_application/","title":"Chapter 3: Application","text":"","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#stage-3-application","title":"Stage 3: Application","text":"<p>Authors:</p> <ul> <li>Eva Mart\u00edn del Pico  </li> <li>Jos\u00e9 M\u00aa Fern\u00e1ndez  </li> </ul> <p>Info</p> <p>In this stage the software can be readily applied to all relevant data, still used mostly by the development team (or the lone developer). The primary focus at this stage is the quality assessment of the software, i.e. provide a battery of tests, ideally fully automated, that ensure valid execution and behaviour. Also, care should be given to providing proper instructions to assure the software can be easily installed and set up in common scenarios</p>","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#learning-outcomes","title":"Learning Outcomes","text":"","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#1-describe-which-are-the-main-activities-that-take-place-during-the-application-phase","title":"1. Describe which are the main activities that take place during the Application phase.","text":"","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#a-documenting-how-the-software-can-be-reliably-used-by-yourself-in-several-months-by-people-external-to-the-development-group-but-related-to-the-scientific-field-or-any-person","title":"a. Documenting how the software can be reliably used by yourself in several months, by people external to the development group but related to the scientific field, or any person","text":"<p>Narrative: </p> <p>Proper documentation of software is critical for ensuring that it can be used reliably over time by various individuals. This is especially important in scientific fields, where research software is often developed to aid in the analysis of data.</p> <p>One way to ensure that software is well-documented is to create a clear and detailed documentation. This documentation should include step-by-step instructions for how to use the software, as well as explanations of any key concepts or terminology that may be unfamiliar to users.</p> <p>Additionally, it can be helpful to provide examples of how the software can be used to solve common problems or perform common tasks. These examples should be relevant to the scientific field in question and should be accompanied by clear explanations of the underlying processes and assumptions.</p> <p>Finally, it is important to update the documentation regularly as the software evolves. This will ensure that users always have access to the most up-to-date information and will help to prevent confusion or errors caused by outdated instructions.</p> <p>By taking the time to create comprehensive and up-to-date documentation, developers can ensure that their software is accessible and reliable for a wide range of users, including those outside of the development group.</p> <p>Learning Experience - Exercise </p> <p>Challenge 1</p> <p>TO ADD</p>","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#b-providing-tests-as-extensively-as-possible-ideally-through-automated-processes","title":"b. Providing tests as extensively as possible (ideally through automated processes)","text":"<p>Narrative: </p> <p>As defined before in Stage 2, testing is a critical component of software development, as it helps to ensure that the software works as intended and is free of bugs or errors. Having the test defined for internal use, it is important to ensure that the software testing process is made available to the end users, such as through automated testing.</p> <p>Automated testing involves creating scripts or programs that can automatically test different aspects of the software, such as its functionality, performance, and security. These scripts can be run repeatedly to ensure that the software is functioning as intended and that any changes or updates do not introduce new errors or bugs.</p> <p>Automated testing can be especially helpful in large software projects, where manual testing can be time-consuming and prone to human error. By automating the testing process, developers can save time and reduce the risk of introducing new errors or issues, while have a systematic way of getting direct feedback from the end users.</p> <p>Learning Experience - Discussion </p> <p>Discussion</p> <p>TO ADD</p> <p>Brainstorming</p> <p>What are the advantages of using tests?</p> <p>Narrative:  Complement previous brainstorming </p> <p>The advantages of testing are: </p> <ol> <li>Helps ensure that when something is fixed, it will not break other things or if it does, it will not go unnoticed. </li> <li>Ensure that the documented functionality is stable, as well as identifying potential bugs and/or issues.</li> <li>Essential for reproducibility</li> <li>Enhance the overall trust that the software will work as intended</li> </ol>","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#c-setting-up-communication-channels","title":"c. Setting up Communication channels","text":"<p>Setting communication channels allow users to: </p> <ul> <li>Report any problems or pose questions about deployment, usage and documentation </li> <li>Address issues/bugs.</li> </ul> <p>Learning Experience - Discussion. </p> <p>Discussion</p> <p>What is your preferred communication channel as a user? and as a developer? Why? </p> Learning outcomes already covered in previos sections <ol> <li>For each activity, explain why it\u2019s important. </li> </ol> <ol> <li>Documenting how the software can be reliably used by people external to the development group or person</li> <ol> <li>To ensure adoption/use of the software outside the original developer</li> </ol> <li>Providing tests as extensively as possible (ideally through automated processes) </li> <ol> <li>Helps to ensure that when something is fixed, it will not break other things or if it does, it will not go unnoticed.</li> <li>Ensure that the documented functionality is stable, as well as identifying potential bugs and/or issues.</li> <li>Essential for reproducibility</li> <li>Enhance the overall trust that the software will work as intended </li> </ol> <li>Setting up Communication channels</li> <ol> <li>Users to report any problems or pose questions about usage and documentation.</li> <li>Clarifying the process to address issues/bugs: what it is expected to report, which technical details should be provided, the code of conduct, etc...</li> <li>Different user profiles require different communication channels. i.e. a potential developer and an end user could use different communication and reporting channels.</li> </ol> </ol>","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#3-identify-the-specific-smp-questions-that-are-relevant-in-this-phase","title":"3. Identify the specific SMP questions that are relevant in this Phase.","text":"<p>Narrative: </p> <p>SMP questions relevant to this phase: </p> <ul> <li>What type of documentation is available, provided with the software and delivered under the same conditions? </li> <li>Documentation in general as well as README, API documentation, docstring in source code, input and usage examples, and tutorial in particular are relevant. </li> </ul> <p>Questions not mapped yet in the SMP</p> <p>Some questions that belong here are still not mapped in the SMP wizard</p>","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch3_application/#4-using-the-elixir-smw-fill-in-the-appropriate-information-to-each-smp-question-that-is-relevant-to-this-phase","title":"4. Using the ELIXIR SMW, fill in the appropriate information to each SMP question that is relevant to this Phase.","text":"<p>Learning Experience - Exercise: </p> <p>Challenge 3</p> <p>Go to the project in the SMW and complete the previous questions for a piece of software.</p>","tags":["Application","Prototype","Communication","Community"]},{"location":"chapters/ch4_production/","title":"Chapter 4: Production","text":"","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch4_production/#stage-4-production-production-software-working-on-real-world-data-in-a-scalable-and-stable-manner","title":"Stage 4: Production (production software working on real-world data in a scalable and stable manner)","text":"<p>Authors:</p> <ul> <li>Fotis Psomopoulos  </li> </ul> <p>Info</p> <p>In this phase, the software is used to generate publishable research data in a consistent, stable and reproducible way. The software should be easily reusable by other researchers with their datasets. Often this is the time when the software is being deployed on a High-Performance Computing infrastructure (e.g. local cluster, supercomputer etc.) or a cloud infrastructure. To ensure the software can be easily and successfully deployed, soft and hard dependencies need to be captured (e.g. versions of libraries or packages, databases and other resources, listing required / recommended packages, etc). This is often done by bundling and packaging all necessary software through different approaches, including static binaries, software containers, virtual machines or any other solution that encapsulates the entire required environment. Specific dependencies on hardware (e.g. CPU optimisations, GPU model, etc) needed by the different execution profiles should also be documented clearly.</p>","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch4_production/#learning-outcomes","title":"Learning Outcomes","text":"","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch4_production/#1-describe-what-are-the-key-considerations-that-need-to-be-made-aware-during-the-production-phase","title":"1. Describe what are the key considerations that need to be made aware during the Production phase.","text":"","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch4_production/#a-ensure-the-re-use-and-reproducibility-of-the-software","title":"a. ensure the (re-)use and reproducibility of the software","text":"<p>Narrative: Explain that (re-)use and reproducibility of the software are fundamental aspects of a research software, when considered ready for production phase. The most crucial aspect here is to ensure the (re-)use and reproducibility of the software, by clearly documenting any OS/Software/hardware dependencies.  This can be achieved through different methods (incl. registry and package managers, containerisation, etc.)</p> <p>Learning experience</p> <p>Exercise</p> <p>Challenge 1</p>","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch4_production/#2-for-each-consideration-explain-why-its-important","title":"2. For each consideration, explain why it\u2019s important.","text":"<p> covered in the previous Learning Outcome ``` a. ensure the (re-)use and reproducibility of the software</p> <p>Software often depends on libraries and their versions that may not be available on some systems. Packaging the software into easy-to-use forms (e.g. R / python / conda packages, pre-compiled binaries, containers or virtual machines, etc.) can greatly facilitate its (re)use and adoption, as well as ensure (to an extent) its reproducibility  ``` </p>","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch4_production/#3-identify-the-specific-smp-questions-that-are-relevant-in-this-phase","title":"3. Identify the specific SMP questions that are relevant in this Phase.","text":"<p>Narrative:  </p> <p>Enumerate the questions: </p> <ul> <li>Interoperability?</li> </ul>","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch4_production/#4-using-the-elixir-smw-fill-in-the-appropriate-information-to-each-smp-question-that-is-relevant-to-this-phase","title":"4. Using the ELIXIR SMW, fill in the appropriate information to each SMP question that is relevant to this Phase.","text":"<p>Learning Experience </p> <p>Exercise: </p> <p>Go to the workspace you just created in the SMW and complete the previous questions for a piece of software.</p>","tags":["Production","Stability","Scalability"]},{"location":"chapters/ch5_publication/","title":"Chapter 5: Publication","text":"","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#stage-5-publication","title":"Stage 5: Publication","text":"<p>Authors:</p> <ul> <li>Johan Gustafsson</li> <li>Leyla Jael Castro  </li> </ul> <p>Info</p> <p>At this stage the software is ready to be used and generate the intended results. It is a good practice to also create a first release at this point (and then every time that the software is upgraded and new, revised or improved functionality is added). Independent from the publication of research results, the software itself should also be published in a software-oriented journal, or deposited to a software archive. In addition, it is a good practice to register your software in a community-oriented software registry.</p>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#learning-outcomes","title":"Learning Outcomes","text":"","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#1-describe-what-are-the-key-decisions-that-need-to-be-made-during-the-publication-phase","title":"1. Describe what are the key decisions that need to be made during the Publication phase.","text":"","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#a-document-the-way-people-should-cite-the-software","title":"a. Document the way people should cite the software","text":"<p>Narrative: Explain that including citation information gives recognition to those participating in the development and mention some possible options.</p> <p>Similar to a scientific article, a software also has a title, a description, and co-authors (i.e., people involved in the development from its conception to its deployment), and all of those elements are part of a software citation.  Software citation should be included for the code source and releases (different releases can involve different co-authors) by using a CFF file, bibtex of JSON-LD (for instance following CodeMeta or Bioschemas Computation Tool specifications).</p> <p>Learning experience</p> <p>Exercise </p> <p>Challenge 1</p> <p>Create a CFF file for any software you have participated in the development. Remember to include ORCIDs for the co-authors.</p> Solution <pre><code>cff-version: 1.2.0\nmessage: \"If you use this software, please cite it as below.\"\nauthors:\n- family-names: \"Doe\"\n  given-names: \"Jane\"\n  orcid: \"https://orcid.org/0000-0000-0000-0000\"\n- family-names: \"Dude\"\n  given-names: \"John\"\n  orcid: \"https://orcid.org/0000-0000-0000-XXXX\"\ntitle: \"My awesome project\"\nversion: 1.0.0\nurl: \"https://github.com/example-group/example-repo\"\n</code></pre> <p>Challenge 2</p> <p>Find any repository in GitHub without citation information. Are citation files a common practice in your team?</p> Solution <p>There are many  If any of your repos fall in the no citation bag, please start adding citation information now </p> <p>Challenge 3</p> <p>Discuss with your peers who should be included as co-author for a software. What practices are followed in your team?</p> Solution <p>Be aware that co-authorship practices might change from team to team. If some roles are not included as co-authors, it is a godd practice to still name them in the software repositories as contributors recognising their role in the development.</p>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#b-create-a-release","title":"b. Create a release","text":"<p>Narrative: Explaing what a release is and what elements should be present.</p> <p>Whenever a software has been upgraded with some additional, revised or improved functionality, it is a good practice to create a new release, accompanied by a CHANGELOG explaining what is new wrt the previous release.</p> <p>Learning experience</p> <p>Exercise</p> <p>Challenge 1</p> <p>Brainstorm reasons for creating releases and maintaining a CHANGELOG. Why is this necessary even if version control is being used for development?</p> Solution <p>Reasons to use CHANGELOG, including explanation of the types of changes you might record in the log. Comments on whether or not CHANGELOG are also needed outside releases.</p>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#c-decide-where-to-publish-your-softwarerelease","title":"c. Decide where to publish your software/release","text":"<p>Narrative: Explain options to publish/deposit software.</p> <p>Whether a journal-style or a deposition is chosen, either way software/releases should be published. Even if the source code is not open, it is still useful to let the world know about the existence of a pieace of software. </p> <p>Learning experience</p> <p>Exercise</p> <p>Challenge 1</p> <p>Make a list of your key drivers/requirements when publishing your software. Some publishing platforms for software include software-oriented journals (e.g., Journal of Open Source Software (JOSS), Software X, BioMedCentral Software publications \u2013see software at the Journal of Biomedical Semantics, Bioinformatics Application Notes \u2013although not exlusive for software), and software archives (e.g., Software Heritage Foundation, Zenodo \u2013although not exclusive for software) Is it authorship on a primary publication, findability, reusability, contributing to a community, something else? Which publishing platforms align closely with your drivers/requirements? do you know the expectations of your research community? Discuss with peers.</p> Solution <p>A list of your requirements and which publication / registration / deposition options match that requirement best</p>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#d-create-persistent-global-and-unique-identifiers-that-point-to-each-released-version-of-the-software","title":"d. Create persistent, global and unique identifiers that point to each released version of the software","text":"<p>Narrative: Outline some options for generating persistent identifiers for software and the sort of identifiers that exist.</p> <p>Somehow this goes hand-in-hand with \u201cwhere to publish your software\u201d as some kind of identifier will be assigned to your software/release in the examples given for platforms where to publish software. There are two main kind of identifiers, intrinsic (e.g., hashcode calculated from the source code) and extrinsic (assigned by the platform where the software is published/deposited).</p> <p>Learning experience</p> <p>Exercise: </p> <p>Challenge 1</p> <p>Persistent identifiers usally relate directly to the location you publish or deposit your software. Based on your the examples listed above, which persistent identifier method is immediately available to you? Discuss why this does or does not meet your expectations (i.e., your list of requirements for publishing). If not, discuss what your other options are for generating an identifier, and the potential benefits of each.</p> Solution <p>Pros and cons of the different alternatives to identify software/releases. Hint: depending on your requirements, you might want to go for multiple publishing platforms.</p>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#e-register-your-software-in-a-community-driven-registry","title":"e. Register your software in a community-driven registry","text":"<p>Narrative: Outline some options to register software.</p> <p>Community-driven registries will make your software even more findable, specially for your own community.  Communities can be broad, e.g., research software engineers, specific to a particular purpose, e.g., used for machine learning purposes, specific to a particular community, e.g., bioinformaticians.</p> <p>Learning experience</p> <p>Exercise: </p> <p>Challenge 1</p> <p>List some software registries that your are aware of.</p> Solution <p>Two examples are Research software directory and bio.tools</p>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#2-for-each-decision-explain-why-its-important","title":"2. For each decision, explain why it\u2019s important.","text":"<p> covered in the previous LO </p> <pre><code>a. Citation\n- Essential to communicate how the authors want the work to be referenced by their peers, and lead the way to acknowledgement and recognition of their effort\n- People involved in the development get credit for it\n- Regardless of the status of your software (none of multiple releases), people will be aware on how to cite your software\n\nb. Releases\n- Releases and CHANGELOGs contribute make them easier to understand the lifecycle of medium- and long-term software developments, improving traceability\n- Even for short-term developments, releases are a good practice as they provide a version \"frozen\" in time corresponding to a particula status of the software lifecylce\n- CHANGELOGs are useful to communicate changes, developers and users should have enough information (e.g., through the CHANGELOG file) to assess the impact of the changes on ongoing projects that rely on the software\n\nc. Formal publication\n- Journal-like platforms to publish software usually provide feedback at the time of submission, i.e., peer-reviews which could help improve narrative and scope\n- Deposition platforms contribute to preservation and preservation contributes to reproducibility (together with the releases --\"frozen\" versions of your software)\n\nd. PIDs\n- Researchers need to be able to find (via the persistent identifier) a specific version of software that has been used to generate published results. This is crucial in order to facilitate reproducibility of research results.\n\ne. Registries\n- Registries make it easier to find your software, particularly for communities of practice\n- Registries collect some metadata about your software, making it easier to, e.g., connecting it to other digital objects and make them available to aggregators\n- Community-driven registries could also help you learn some of the expectations of your own community\n</code></pre>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#3-identify-the-specific-smp-questions-that-are-relevant-in-this-phase","title":"3. Identify the specific SMP questions that are relevant in this Phase.","text":"<p>Narrative:  </p> <p>Enumerate the questions: </p> <ul> <li>Documentation 1.a.5. Release notes</li> <li>Documentation 1.a.7. CHANGELOG</li> <li>[Not covered in the lesson] Versioning 2. Do you use semantic versioning?</li> <li>Reproducibility 1. Do you provide releases of your software?</li> <li>Recognition 1. Do you include citation information (i.e. how to cite your software in the form of citation.cff, codemeta.json or bibtex)?</li> <li>Recognition 2. Do the releases have a persistent global unique identifier (such as release on Zenodo with DOI, snapshot or/and release referenced on Software Heritage with SWHID)?</li> <li>Recognition 3. Does the citation information contain ORCIDs of (at least one of) the authors?</li> <li>Recognition 4. Is the software registered in a domain-specific registry</li> </ul>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch5_publication/#4-using-the-elixir-smw-fill-in-the-appropriate-information-to-each-smp-question-that-is-relevant-to-this-phase","title":"4. Using the ELIXIR SMW, fill in the appropriate information to each SMP question that is relevant to this Phase.","text":"<p>Learning Experience </p> <p>Exercise: </p> <p>Go to the workspace you just created in the SMW and complete the previous questions for a piece of software.</p>","tags":["Publication","Registries","Repositories","Changelog"]},{"location":"chapters/ch6_wrap-up_conclusions/","title":"Conclusions","text":"","tags":["Conclusion"]},{"location":"chapters/ch6_wrap-up_conclusions/#wrap-up-conclusions","title":"Wrap-up / Conclusions","text":"","tags":["Conclusion"]},{"location":"keywords/","title":"Keyword list / Glossary","text":"<p>Here\u2019s a lit of used keywords:</p>"},{"location":"keywords/#application","title":"Application","text":"<ul> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#changelog","title":"Changelog","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#communication","title":"Communication","text":"<ul> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#community","title":"Community","text":"<ul> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#conclusion","title":"Conclusion","text":"<ul> <li>Conclusions</li> </ul>"},{"location":"keywords/#construction","title":"Construction","text":"<ul> <li>Chapter 2: Construction</li> </ul>"},{"location":"keywords/#core-features","title":"Core features","text":"<ul> <li>Chapter 2: Construction</li> </ul>"},{"location":"keywords/#inception","title":"Inception","text":"<ul> <li>Chapter 1: Start</li> </ul>"},{"location":"keywords/#introduction","title":"Introduction","text":"<ul> <li>Introduction</li> </ul>"},{"location":"keywords/#license","title":"License","text":"<ul> <li>Chapter 1: Start</li> </ul>"},{"location":"keywords/#production","title":"Production","text":"<ul> <li>Chapter 4: Production</li> </ul>"},{"location":"keywords/#prototype","title":"Prototype","text":"<ul> <li>Chapter 2: Construction</li> <li>Chapter 3: Application</li> </ul>"},{"location":"keywords/#publication","title":"Publication","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#registries","title":"Registries","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#repositories","title":"Repositories","text":"<ul> <li>Chapter 5: Publication</li> </ul>"},{"location":"keywords/#scalability","title":"Scalability","text":"<ul> <li>Chapter 4: Production</li> </ul>"},{"location":"keywords/#software-management-plan","title":"Software Management Plan","text":"<ul> <li>Introduction</li> </ul>"},{"location":"keywords/#stability","title":"Stability","text":"<ul> <li>Chapter 4: Production</li> </ul>"},{"location":"keywords/#standards","title":"Standards","text":"<ul> <li>Chapter 1: Start</li> </ul>"},{"location":"keywords/#training","title":"Training","text":"<ul> <li>Introduction</li> </ul>"},{"location":"keywords/#versioning","title":"Versioning","text":"<ul> <li>Chapter 1: Start</li> </ul>"}]}